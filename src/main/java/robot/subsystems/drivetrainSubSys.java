// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.


package robot.subsystems;
import robot.Constants;

import com.kauailabs.navx.frc.AHRS;
import edu.wpi.first.wpilibj.SPI;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.Timer;

import com.ctre.phoenix.motorcontrol.StatorCurrentLimitConfiguration;
import com.ctre.phoenix.motorcontrol.SupplyCurrentLimitConfiguration;

import edu.wpi.first.wpilibj2.command.SubsystemBase;

import com.ctre.phoenix.motorcontrol.NeutralMode;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonFX;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.motorcontrol.MotorControllerGroup;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class drivetrainSubSys extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
private WPI_TalonFX leftMotor1;
private WPI_TalonFX leftMotor2;
private MotorControllerGroup leftMotorGrp;
private WPI_TalonFX rightMotor1;
private WPI_TalonFX rightMotor2;
private MotorControllerGroup rightMotorGrp;
private DifferentialDrive driveCtrl;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private AHRS gyro = new AHRS(SPI.Port.kMXP);

    private static final double GYROCORRLIMIT = 0.5;
    private static final double GYROCORRCNST =  0.05;  //-- 0.35?

    // -------------- Drive Motor Current Limiting ---------------
    /**
     * Description:
     * The Current Limit example demonstrates the Talon's ability to perform current limiting.
     * The Current Limit Feature expands across 4 different functions:
     * 1.) configPeakCurrentLimit(), Config current threshold to trigger current limit
     * 2.) configPeakCurrentDuration(), Config duration after peak current to trigger current limit
     * 3.) configContinousCurrentLimit(), Config current to maintain after limit is triggered
     * 4.) enableCurrentLimit(bool enable), Enable/Disable Current Limiting on Talon
     *
     * This example has been configured to hold 10 Amps almost instantly after current
     * exceed peak current limit of 15 Amps.
     * 
     * 
     * Supported Version:
     * 	- Talon FX: 20.2.3.0
 */

    // Stator Limits
    static final boolean talonStatorLimit = false;
    static final double kStatorTriggerThresholdAmp = 30; 
    static final double kStatorTriggerThresholdTime = 1;
    static final double kStatorLimitAmp = 25;

    // Supply Limits
    static final boolean talonSupplyLimit = false;          // controls how much current the motor controllers can consume when at full load (boolean for on/off)
    static final double kSupplyTriggerThresholdAmp = 30; 
    static final double kSupplyTriggerThresholdTime = 0.5;
    static final double kSupplyLimitAmp = 25; 

    // Drive Motor Current Limiting Used in 2020 Robot with 3 motors on each side
    //private static final int DRIVE_MTR_MAX_PEAK_CURRENT = 25;    // Amps
    //private static final int DRIVE_MTR_MAX_PEAK_DURATION = 100;   // Milliseconds
    //private static final int DRIVE_MTR_MAX_CONT_CURRENT = 25;    // Amps
    //private static final boolean DRIVE_MTR_CURRENT_LIMIT_FLAG = true;
    // Example from CTRE 
    //                                                                  enabled | Limit(amp) | Trigger Threshold(amp) | Trigger Threshold Time(s)
    // motor.configStatorCurrentLimit(new StatorCurrentLimitConfiguration(true,      20,                25,                1.0));
    // motor.configSupplyCurrentLimit(new SupplyCurrentLimitConfiguration(true,      10,                15,                0.5));

    private static Timer driveTimer = new Timer();
    private double avgVelMinus1 = 0;
    private double avgVelMinus2 = 0;
    private double avgVelMinus3 = 0;
    private double lastTime =     0;
    private double avgVelocity =  0;
    private double lastDist =     0;
    private double currDist =     0;
    public double currPwr =      0;

    public drivetrainSubSys() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
leftMotor1 = new WPI_TalonFX(1);
 
 

leftMotor2 = new WPI_TalonFX(2);
 
 

leftMotorGrp = new MotorControllerGroup(leftMotor1, leftMotor2  );
 addChild("LeftMotorGrp",leftMotorGrp);
 

rightMotor1 = new WPI_TalonFX(3);
 
 

rightMotor2 = new WPI_TalonFX(4);
 
 

rightMotorGrp = new MotorControllerGroup(rightMotor1, rightMotor2  );
 addChild("RightMotorGrp",rightMotorGrp);
 

driveCtrl = new DifferentialDrive(leftMotorGrp, rightMotorGrp);
 addChild("DriveCtrl",driveCtrl);
 driveCtrl.setSafetyEnabled(true);
driveCtrl.setExpiration(0.1);
driveCtrl.setMaxOutput(1.0);



    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

    leftMotorGrp.setInverted(true);

    leftMotor1.setNeutralMode(NeutralMode.Brake);
    leftMotor2.setNeutralMode(NeutralMode.Brake);
    rightMotor1.setNeutralMode(NeutralMode.Brake);
    rightMotor2.setNeutralMode(NeutralMode.Brake);


    /**
     * Configure the current limits that will be used
     * Stator Current is the current that passes through the motor stators.
     *  Use stator current limits to limit rotor acceleration/heat production
     * Supply Current is the current that passes into the controller from the supply
     *  Use supply current limits to prevent breakers from tripping
     * 
     * https://phoenix-documentation.readthedocs.io/en/latest/ch13_MC.html#current-limit
     * 
     *                                                                        enabled | Limit(amp) | Trigger Threshold(amp) | Trigger Threshold Time(s)  */
    //leftMotor1
    leftMotor1.configStatorCurrentLimit(new StatorCurrentLimitConfiguration(talonStatorLimit, kStatorLimitAmp, kStatorTriggerThresholdAmp, kStatorTriggerThresholdTime));
    leftMotor1.configSupplyCurrentLimit(new SupplyCurrentLimitConfiguration(talonSupplyLimit, kSupplyLimitAmp, kSupplyTriggerThresholdAmp, kSupplyTriggerThresholdTime));
    //leftMotor2
    leftMotor2.configStatorCurrentLimit(new StatorCurrentLimitConfiguration(talonStatorLimit, kStatorLimitAmp, kStatorTriggerThresholdAmp, kStatorTriggerThresholdTime));
    leftMotor2.configSupplyCurrentLimit(new SupplyCurrentLimitConfiguration(talonSupplyLimit, kSupplyLimitAmp, kSupplyTriggerThresholdAmp, kSupplyTriggerThresholdTime));
    //RightMotor1
    rightMotor1.configStatorCurrentLimit(new StatorCurrentLimitConfiguration(talonStatorLimit, kStatorLimitAmp, kStatorTriggerThresholdAmp, kStatorTriggerThresholdTime));
    rightMotor1.configSupplyCurrentLimit(new SupplyCurrentLimitConfiguration(talonSupplyLimit, kSupplyLimitAmp, kSupplyTriggerThresholdAmp, kSupplyTriggerThresholdTime));
    //RightMotor2
    rightMotor2.configStatorCurrentLimit(new StatorCurrentLimitConfiguration(talonStatorLimit, kStatorLimitAmp, kStatorTriggerThresholdAmp, kStatorTriggerThresholdTime));
    rightMotor2.configSupplyCurrentLimit(new SupplyCurrentLimitConfiguration(talonSupplyLimit, kSupplyLimitAmp, kSupplyTriggerThresholdAmp, kSupplyTriggerThresholdTime));

    initEncoders();
    driveTimer.reset();
    driveTimer.start();

    
}
    //private double k_EncConvConst = 0.0010475;

    @Override
    public void periodic() {
        // This method will be called once per scheduler run
        updateCurrentVelocity();
        updateShuffleboard();
    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void stop() {
        driveCtrl.arcadeDrive(0, 0);
    }
    public void curveDrive(double speed, double rotation, boolean inplace ){
        driveCtrl.curvatureDrive(speed, rotation, inplace);
    }

    public void arcadeDrive(double speed, double rotation){
        driveCtrl.arcadeDrive(speed, rotation);
    }

    public void tankDrive(double leftSpeed, double rightSpeed){
        driveCtrl.tankDrive(leftSpeed, rightSpeed);
    }

    public void driveStraightToHdg(double pwr, double targetYaw) {
        double motorAngle = calcArcadeGyroCorrection(targetYaw);
        currPwr = pwr;

        driveCtrl.arcadeDrive(pwr, motorAngle);
    }

    //---------------------------------------------------\\
    //--------------------Gyro Methods-------------------\\
    public void resetGyro(){
        gyro.reset();
    }

    public double getGyroYaw(){
        return gyro.getYaw();
    }

    public double getGyroRate() {
        return gyro.getRate() * 57.259;
    }

    //---------Calculate Gyro Corrected Angle------------\\
    private double calcArcadeGyroCorrection(double tgtYaw) {
        double yawError = tgtYaw - getGyroYaw();
        if (yawError > 180)     { yawError -= 360; }
        if (yawError < -180)    { yawError += 360; }
        double correctionValue = yawError * GYROCORRCNST;

        if (correctionValue > GYROCORRLIMIT) {
            correctionValue = GYROCORRLIMIT;
        } else if (correctionValue < -GYROCORRLIMIT){
            correctionValue = -GYROCORRLIMIT;
        }
        return correctionValue;
    }

    //----------------------------------------------------\\
    //----------------------Velocity----------------------\\

    private void updateCurrentVelocity(){
        double time, delta_Time, delta_Dist, currVel;
        time = driveTimer.get();
        delta_Time = time - lastTime;
        lastTime = time;
        if (delta_Time == 0) { delta_Time = 0.00000001; }

        currDist = getAvgEncoderDist();
        delta_Dist = currDist - lastDist;
        lastDist = currDist;
        currVel = delta_Dist / delta_Time;
        
        avgVelMinus3 = avgVelMinus2;
        avgVelMinus2 = avgVelMinus1;
        avgVelMinus1 = currVel;
        avgVelocity = (avgVelMinus1 + avgVelMinus2 + avgVelMinus3) / 3;


    }

    //---------------------------------------------------\\
    //-------------------Encoder Methods-----------------\\

    public void initEncoders() {
        leftMotor1.setSensorPhase(true);
        rightMotor1.setSensorPhase(false);
    }

    public void resetEncoders(){                    // Set Encoders to zero
        rightMotor1.setSelectedSensorPosition(0,0,10);
        leftMotor1.setSelectedSensorPosition(0,0,10);
    }


    public int getLeftEncoder()                 { return (int)-leftMotor1.getSelectedSensorPosition(0); }
    public int getRightEncoder()                { return (int)rightMotor1.getSelectedSensorPosition(0); }

    public double getLeftEncoderDist()          { return (getLeftEncoder() *  Constants.k_EncConvConst); }
    public double getRightEncoderDist()         { return (getRightEncoder() * Constants.k_EncConvConst); }
    
    public double getAvgEncoderDist()           { return ((getLeftEncoderDist() + getRightEncoderDist()) / 2.0 ); }
    public double getCurrentVel()               { return avgVelocity; }
    public double getCurrentDist()              { return currDist; }

    //------------------------------------------------\\
    //-------------------Shuffleboard-----------------\\
    private void updateShuffleboard() {
        SmartDashboard.putNumber("Enc-Left Cnt", getLeftEncoder());
        SmartDashboard.putNumber("Enc-Left Dist", getLeftEncoderDist());
    
        SmartDashboard.putNumber("Enc-Right Cnt", getRightEncoder());
        SmartDashboard.putNumber("Enc-Right Dist", getRightEncoderDist());

        SmartDashboard.putNumber("Avg Dist", getAvgEncoderDist());
        SmartDashboard.putNumber("Velocity", getCurrentVel());
        
        SmartDashboard.putNumber("Gyro Yaw", getGyroYaw());
        SmartDashboard.putNumber("Gyro Rate", getGyroRate());

        SmartDashboard.putNumber("Current Power", currPwr);
    }
}

