// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Command.

package robot.commands;
import edu.wpi.first.wpilibj2.command.CommandBase;
import edu.wpi.first.wpilibj.Timer;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import robot.subsystems.drivetrainSubSys;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class driveSwingTurnCmd extends CommandBase {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
        private final drivetrainSubSys m_drivetrainSubSys;
    private double m_speed;
    private double m_rotation;
    private double m_dist;
    private double m_hdg;
    private String m_mode;
    private boolean m_brakeFlag;
    private double m_timeOut;
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
    
    Timer commandTmr = new Timer();
    Timer startTmr   = new Timer();

	int stallCtr = 0;
    final double START_TIME = 0.15;						// Time to wait for motors to start moving robot
    final double STOP_PWR  = 0.85;						// Power to reverse motors to brake
	final double STALL_VELOCITY_RATE = 5.0;				// Driving distance speed below this is a stall	
	final double STALL_ROTATION_RATE = 5.0;				// Roation Rate less than this Degrees per second is a stall

    int driveProfileFlag, stopFlag;
    double currPwr, currRotation, stopPwr;
    double tgtYaw;
    double m_RemainTgtDist, m_RemainTgtYaw, currDist, currYaw, currGyroRate, currSpeed;
    
    public enum DriveMode { DIST, HDG };
    private DriveMode mDriveMode = DriveMode.DIST;	    // this defines drive mode
    
    public enum DriveState { START, DRIVINGDIST , DRIVINGHDG, BRAKING, STALLED, ATEND, DONE };
    private DriveState mDriveState = DriveState.START;	// this keeps track of our current Drive State
    
    public enum DriveDir { FWD, REV };
    private DriveDir mDriveDir = DriveDir.FWD;	// this keeps track of our current drive direction 
    
    public enum TurnDir { CW, CCW };		// Clock Wise, Counter Clock Wise
    private TurnDir mTurnDir = TurnDir.CW;	// this keeps track of our current turn direction    
    

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS


    public driveSwingTurnCmd(double speed, double rotation, double dist, double hdg, String mode, boolean brakeFlag, double timeOut, drivetrainSubSys subsystem) {

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        m_speed = speed;
        m_rotation = rotation;
        m_dist = dist;
        m_hdg = hdg;
        m_mode = mode;
        m_brakeFlag = brakeFlag;
        m_timeOut = timeOut;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

        m_drivetrainSubSys = subsystem;
        addRequirements(m_drivetrainSubSys);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }

    // Called when the command is initially scheduled.
    @Override
    public void initialize() {
    	m_drivetrainSubSys.resetEncoders();   // Reset Drivetrain Encoders

    	// Determine turn mode ( Heading or Distance )
    	if ( m_mode.equals("HDG")) 	{ 
			mDriveMode = DriveMode.HDG;
			System.out.println("*");
			System.out.println("******** HDG Turn *********");
		} else {
			mDriveMode = DriveMode.DIST;
			System.out.println("******** DIST Turn *********");
		}

    	// Determine Drive "Fwd" or "Rev" direction
		if (m_speed >=0 ){
			mDriveDir = DriveDir.FWD;
			System.out.println("******** Swing turn Forward *********");
		} else {
			mDriveDir = DriveDir.REV;
			System.out.println("******** Swing turn Reverse *********");
		}

    	// Insure correct distance polarity in drive distance based on Drive sped
    	if  (mDriveMode == DriveMode.DIST) {
    		if (mDriveDir == DriveDir.FWD)  {   
    			if ( m_dist < 0 ) m_speed *= -1;		// Distance must be Positive if speed is positive				 			
    		} else {    			
				if ( m_dist > 0 ) m_speed *= -1;		// Distance must be negative if speed is negative
    		}
    	}

		if ( mDriveDir == DriveDir.FWD )  {
			if (m_rotation >= 0) {
				mTurnDir = TurnDir.CW;		// Clockwise turn
				System.out.println("******** Clockwise *********");	
			} else {
				mTurnDir = TurnDir.CCW;		// Counter Clockwise turn
				System.out.println("******** Counter Clockwise *********");				
			}
		} else {
			// were going in reverse
			if (m_rotation >= 0) {
				mTurnDir = TurnDir.CW;		// Clockwise turn
				System.out.println("******** Clockwise *********");	
			} else {
				mTurnDir = TurnDir.CCW;		// Counter Clockwise turn
				System.out.println("******** Counter Clockwise *********");				
			}
		}
		
        // Set correct Braking stop power polarity
    	if (m_speed < 0) 	stopPwr =   STOP_PWR;		// Brake Power must be opposite of drive pwr
    	else 				stopPwr -=  STOP_PWR;

		mDriveState = DriveState.START;									// We are just starting out will need to accel.
    	startTmr.reset();
    	startTmr.start();
    	stallCtr = 0;
		System.out.println("******** We have Started *********");
		mDriveState = DriveState.START;
    }

    // Called every time the scheduler runs while the command is scheduled.
    @Override
    public void execute() {
              
        // ---- Look up key data to start ----
    	currDist = m_drivetrainSubSys.getAvgEncoderDist();
    	currYaw = m_drivetrainSubSys.getGyroYaw();
    	currSpeed = m_drivetrainSubSys.getCurrentVel();
		currGyroRate = m_drivetrainSubSys.getGyroRate();

    	m_RemainTgtDist = m_dist - currDist;    // Used only if mDriveMode = DriveMode.DIST
    	m_RemainTgtYaw = m_hdg - currYaw;    	// Used only if mDriveMode = DriveMode.HDG

    	// ----- State - START (Initially not moving, wait for start timer to elapse) -----
    	if (mDriveState == DriveState.START){
    		// were are just starting, we need to wait to give time for motion to begin
    		currPwr = m_speed;
			currRotation = m_rotation;
    		if(startTmr.get() > START_TIME) {
    			// we should now be moving so its time to change state
				System.out.println("******** The startup time has elapsed *****");
    			if (mDriveMode == DriveMode.DIST) mDriveState = DriveState.DRIVINGDIST;
    			else							  mDriveState = DriveState.DRIVINGHDG;	
    		}
    	}

		// Diagnostic data
        if (mDriveState == DriveState.DRIVINGDIST) {
            System.out.println("******** We are SWING turning Remain Distance=" + m_RemainTgtDist +
							   " CurrVel=" + currSpeed + " Rot Rate=" + currGyroRate);
        } else {
            //DRIVINGHDG
            System.out.println("******** We are SWING turning Remaing Heading=" + m_RemainTgtYaw +
							   " CurrVel=" + currSpeed + " Rot Rate=" + currGyroRate);
        }

    	// ----- State - DRIVING_DIST (Test if we have completed route by Distance) -----
    	if (mDriveState == DriveState.DRIVINGDIST){
    		// ----- Check to see if we have are done -----
    		if (((mDriveDir == DriveDir.FWD) && (m_RemainTgtDist <= 0)) ||
    			((mDriveDir == DriveDir.REV) && (m_RemainTgtDist >= 0))){
    			// We have hit our target distance so were done
    			if (m_brakeFlag) {
    				// we need to brake to a stop
					System.out.println("******** We need to brake (dist turn) *********");
    				mDriveState = DriveState.BRAKING;
    				currPwr =  stopPwr;
    			} else {
    				// were all done just exit
					System.out.println("******** We have completed the Arc Turn DONE *********");
    				mDriveState = DriveState.ATEND;
    				return;	// Were all done so get out
    			}
    		}
    	}

		// ----- State - DRIVING_HDG (Test if we have completed route by Heading) -----
		if (mDriveState == DriveState.DRIVINGHDG){
			// ----- Check Heading to see if we have are done) -----
			// are we going fwd or rev ???? Turning lef or right
			
			
			if ((mTurnDir == TurnDir.CW) && (m_RemainTgtYaw <= 0)) {
				// We have completed the requested turn so it's time to end
				System.out.println("******** We have completed the CW Turn *********");
				mDriveState = DriveState.ATEND;     				
			}
			if  ((mTurnDir == TurnDir.CCW) && (m_RemainTgtYaw >= 0)) {
				// We have completed the requested turn yaw so it's time to end
				System.out.println("******** We have completed the CCW Turn *********");
				mDriveState = DriveState.ATEND;    				
			}
			if (mDriveState == DriveState.ATEND) {
				// We have completed the requested turn yaw so it's time to check if we need to brake
				if (!m_brakeFlag) {
					System.out.println("******** No Braking Needed ALL Done *********");
					return;	// were all done so get out
				} else {
					// We need to brake
					mDriveState = DriveState.BRAKING; 
					currPwr = stopPwr;
					System.out.println("******** We need to Brake now *********");
				}
			}
		}
		
    	// ----- State - DRIVING/BRAKING (Test to see if we have Stalled (Brake Complete or Collision)) ----
		if ((mDriveState == DriveState.DRIVINGDIST ) ||
		    (mDriveState == DriveState.DRIVINGHDG )  ||
			( mDriveState == DriveState.BRAKING )){	
			// Look for drivetrain velocity to be zero/low 
            if  (((mDriveDir == DriveDir.FWD) && (m_drivetrainSubSys.getCurrentVel() <= STALL_VELOCITY_RATE)) ||
                ((mDriveDir == DriveDir.REV) && (m_drivetrainSubSys.getCurrentVel() >= -STALL_VELOCITY_RATE))) {
                // we have stopped moving we may have hit something so sto
                if (stallCtr >= 3) {
                    if (mDriveState == DriveState.BRAKING){
                        // we are in brake mode and have just come to rest for 3 cycles (60 ms)
						System.out.println("******** We were Braking and have come to a stop *********");
                        mDriveState = DriveState.ATEND;
                        return; // were done so get out
                    } else {
                        // we have hit something and we are not in brake mode
						System.out.println("******** We may have hit something and Stalled *********");
                        mDriveState = DriveState.STALLED;
                        return; // were done so get out
                    }		
                }
				stallCtr++;
            } else {
                // we are moving so reset stall counter
                stallCtr = 0;    			
			}
		}

    	// We got here so we are not done so send pwr to drivetrain
		m_drivetrainSubSys.curveDrive(currPwr, currRotation, false);    		
        //m_drivetrainSubSys.tankDrive(currLeftPwr, currRightPwr);
    }

    // Called once the command ends or is interrupted.
    @Override
    public void end(boolean interrupted) {
        m_drivetrainSubSys.stop();
    }

    // Returns true when the command should end.
    @Override
    public boolean isFinished() {
        if (commandTmr.get() > m_timeOut) {
			System.out.println("******** We have timed out *********");
			return true;
		}				// (Were Done) Cmd has timed out
    	if (mDriveState == DriveState.ATEND)   { return true; } 	// Cmd has completed its distance 	
    	if (mDriveState == DriveState.STALLED) { return true; } 	// We have stalled so exit
    	return false; 
    }

    @Override
    public boolean runsWhenDisabled() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
        return false;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
    }
}
