// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Command.

package robot.commands;
import edu.wpi.first.wpilibj2.command.CommandBase;
import edu.wpi.first.wpilibj.Timer;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import robot.subsystems.drivetrainSubSys;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class drivePointTurnCmd extends CommandBase {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
        private final drivetrainSubSys m_drivetrainSubSys;
    private double m_rotation;
    private double m_hdg;
    private boolean m_brakeFlag;
    private double m_timeOut;
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
    
    Timer startTmr   = new Timer();
    Timer commandTmr   = new Timer();

	int stallCtr = 0;
    final double START_TIME = 0.15;						// Time to wait for motors to start moving robot
    final double STOP_PWR  = 0.1;				        // Power to reverse motors to brake	
	final double STALL_ROTATION_RATE = 5.0;				// Roation Rate less than this Degrees per second is a stall

    int driveProfileFlag, stopFlag;
    double currPwr,stopPwr;
    double tgtYaw;
    double m_RemainTgtDist, m_RemainTgtYaw, currDist, currYaw, currGyroRate, currSpeed;
    
    public enum DriveState { START, DRIVING, BRAKING, STALLED, ATEND, DONE };
    private DriveState mDriveState = DriveState.START;	// this keeps track of our current Drive State
    
    public enum TurnDir { CW, CCW };
    private TurnDir mTurnDir;                       	// this keeps track of our current turn direction    

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS


    public drivePointTurnCmd(double rotation, double hdg, boolean brakeFlag, double timeOut, drivetrainSubSys subsystem) {

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        m_rotation = rotation;
        m_hdg = hdg;
        m_brakeFlag = brakeFlag;
        m_timeOut = timeOut;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

        m_drivetrainSubSys = subsystem;
        addRequirements(m_drivetrainSubSys);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }

    // Called when the command is initially scheduled.
    @Override
    public void initialize() {
    	m_drivetrainSubSys.resetEncoders();   // Reset Drivetrain Encoders
        commandTmr.reset();;
        commandTmr.start();

		// Determine turn Direction
		if ( m_rotation > 0.0 ) {
			mTurnDir = TurnDir.CW;
			System.out.println("******** Turn direction is Clockwise *********");    			
		} else {    			
			mTurnDir = TurnDir.CCW;
			System.out.println("******** Turn direction is Counter Clockwise *********");
		}
    	
        // Set correct Motor Power and Braking stop power polarity
        if (mTurnDir == TurnDir.CW) {
            stopPwr -= STOP_PWR;		// Brake Power must be opposite of drive pwr
        } else {
            stopPwr = STOP_PWR;		    // Brake Power must be opposite of drive pwr
        }

		mDriveState = DriveState.START;									// We are just starting out will need to accel.
    	startTmr.reset();
    	startTmr.start();
    	stallCtr = 0;
		System.out.println("******** We have Started *********");
		mDriveState = DriveState.START;
        currPwr = m_rotation;
    }

    // Called every time the scheduler runs while the command is scheduled.
    @Override
    public void execute() {
        // ---- Look up key data to start ----
    	currYaw = m_drivetrainSubSys.getGyroYaw();
        m_RemainTgtYaw = m_hdg - currYaw;
		currGyroRate = m_drivetrainSubSys.getGyroRate();
    	
    	// ----- Initially not moving, wait for start timer to elapse -----
    	if (mDriveState == DriveState.START){
    		// were are just starting, we need to wait to give time for motion to begin
    		if(startTmr.get() > START_TIME) {
    			// we should now be moving so its time to change state
				System.out.println("******** The startup time has elapsed *****");
    			mDriveState = DriveState.DRIVING;	
    		}
    	}

		// Diagnostic data
    	System.out.println("******** POINT turn Remain_Hdg=" +m_RemainTgtYaw+
                           " CurrRot_Rate="+currGyroRate + " Gyro=" + currYaw);
    	
        // ----- Check - Are we done with the Turn) -----          
        if (((mTurnDir == TurnDir.CW) && (m_RemainTgtYaw <= 0)) ||
            ((mTurnDir == TurnDir.CCW)  && (m_RemainTgtYaw >= 0))) {
                // We have completed the requested turn so it's time to end
                System.out.println("******** We have completed the Turn *********");
                mDriveState = DriveState.ATEND;     				
        }

        // ----- Check - Do we need to Brake Or we are really done ----
        if (mDriveState == DriveState.ATEND) {
            if (m_brakeFlag) {
                // We need to brake
                mDriveState = DriveState.BRAKING; 
                currPwr = stopPwr;
                System.out.println("******** We need to Brake now *********");
            } else {
                return;	// were all done so get out
            }
        }

    	// ----- Check - Have we Stalled or Brake Complete ----
		if ((mDriveState == DriveState.DRIVING ) || ( mDriveState == DriveState.BRAKING )) {	
            if  (((mTurnDir == TurnDir.CW) && (currGyroRate <=  STALL_ROTATION_RATE)) ||
                    ((mTurnDir == TurnDir.CCW)  && (currGyroRate >= -STALL_ROTATION_RATE))) {
                // we have stopped moving we may have hit something so stop
                if (stallCtr >= 3) {
                    if (mDriveState == DriveState.DRIVING){
                        // we have hit something and we are not in brake mode
                        mDriveState = DriveState.STALLED;
                        return; // were done so get out
                    } else {
                        // we are in brake mode and have just come to rest
                        mDriveState = DriveState.ATEND;
                        return;	// were done so get out
                    }		
                }
                stallCtr++;
            } else {
                // we are moving so reset stall timer
                stallCtr = 0;    			
            }
		}

    	// We got here so we are not done yet so continue to send pwr to drivetrain    		
        m_drivetrainSubSys.curveDrive( 0.0, currPwr, true);
    	
    }

    // Called once the command ends or is interrupted.
    @Override
    public void end(boolean interrupted) {
        m_drivetrainSubSys.stop();
    }

    // Returns true when the command should end.
    @Override
    public boolean isFinished() {
    	if (commandTmr.get() > m_timeOut) {
            // (Were Done) Cmd has timed out
            System.out.println("******** We have timed out *********");
            return true;
        }		
    	if (mDriveState == DriveState.ATEND) {
            // (Were Done) robot has reached its detination
            System.out.println("******** We have reached the end *********");
            return true;
        }
        if (mDriveState == DriveState.STALLED) {
            // (Were Done) We have stalled/Stopped
            System.out.println("******** We have STALLED *********");
            return true;
        }
        return false;
    }

    @Override
    public boolean runsWhenDisabled() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
        return false;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
    }
}
